>>INDEX<<ql
TABLE QUERY PROGRAM

       NAME
         ql   provides a set of data query and data manipulation
              commands for use against tables served by cdserver.

       SYNOPSIS
         ql [-V][-#Nm][-nproj][-Sserver_name]

       DESCRIPTION
         ql is an interactive interface to cdserver tables.  It supports
         commands for viewing and manipulating table data (data manipulation
         language).  ql also supports commands to create and drop tables
         (data definition language).

       QL OPTIONS

         The -V option reports the version of ql.  The version report
         includes internal revision numbers, designers name, and the date the
         executable was made.

         The -# option suppresses printing of application number, field
         number, data type, and length, leaving only application name, field
         name, and field value.  This option is only in affect when printing
         complete records.  When printing a selected set of fields, a
         projection, this option has no affect.

         The -N option suppresses printing of the application name and field
         name.  Like the -# option, this option has no affect when printing a
         selected set of fields from the record.

         When the -# and -N options are used together, only the data field
         values are printed.

         The -m option tells ql not to take advantage of multiple record
         retrieval functions.  If specified, ql will always get records from
         the server one at a time.

         The -n option is for specifying the project name.  The default is the
         value of MOACURPROJ in your registry or in your environment.  There
         is no default if MOACURPROJ is not set.

         The -S option allows you to specify a suffix to the name of the 
         server to connect to.  The server can be named when started.  
         See the section on 'Clients using Multiple Servers' for more info.


       QL COMMANDS

       ql supports a set of data manipulation commands and a set of data
       definition commands.  Commands in ql can span more than one line, with
       the carriage return treated as white space.  ql commands are
       terminated with a semicolon (;).  Characters following the semicolon
       are treated as a comment so long as white space separates the
       semicolon from the following comment.  ql commands can also be
       terminated by entering a blank line.

       ql supports the following commands:


>>INDEX<<alter
      ALTER - alter a table definition.
         Syntax: alter [table] <table_name> [index <key_field_list>]
                       [set <field_assignment>];

         This function allows the user to re-declare characteristics of an
         existing table.  If an index specification is given, it will be used
         as the new primary index for the table (the old primary index being
         dropped).  Using the 'set' option allows certain table options to be
         changed.  The following fields may be changed using the set option:
             common:Cds_allow_delete
             common:Cds_base_size
             common:Cds_index_size
             common:Cds_owner
             common:Cds_allow_new_field
             common:Cds_permissions
             common:Cds_buffer_size
             common:Cds_minimum_record
             common:Cds_key_changable
             common:Cds_table_comment

         In most commercial Database Management Systems (DBMS), the alter
         command allows fields to be added or deleted from the table
         structure.  To add or delete a field from a record in CDS, OFB
         programmers can use the replace command. "help advanced examples;"
         gives a ql alternative to using the replace command when adding or
         deleting fields.


>>INDEX<<begin
      BEGIN - start a logical unit of work.
         Syntax: begin|start [work|transaction];

         This command starts a logical unit of work, that stays in affect
         until it is committed (COMMIT) or rolled back (ROLLBACK).

>>INDEX<<cancel
      CANCEL - cancel the current logical unit of work.
         Syntax: rollback|cancel [work|transaction];

         This command cancels the current logical unit of work (LUW), rolling
         back all changes made since the LUW was started.


>>INDEX<<close
      CLOSE - closes a cursor on a table.
         Syntax: close <cursor_name>;

         <cursor_name> is the name of a cursor previously created using the
         declare command.  Once closed, attempting to perform an action on
         the cursor will result in an error.

         Examples:
             close my_list;
             close a_cursor;

>>INDEX<<commit
      COMMIT - commit the current logical unit of work.
         Syntax: commit [work|transaction];

         This command commits the current logical unit of work.

>>INDEX<<compress
      COMPRESS - compress a table using the cds compress function
         Syntax: compress [table] <table_name> [retain] where <criteria>;

         The compress function retains only those records qualified by the
         where clause criteria.  CDS must be able to acquire an exclusive
         lock on the table in order to perform the compression.  The key word
         'retain' is optional, and was added as a reminder that the criteria
         qualifies the records to keep.

>>INDEX<<connect
      CONNECT - connect to a server.
         Syntax: connect to <server_name>
                         connect using <table_name>

         If the server_name is used, ql will attempt to connect to the server
         of that name for your given project and revision.

         If the table_name is used, ql will attempt to get a list of server
         names for that table by selecting all of the common:Cds_server_name
         fields from the table records.  Ql will then attempt to connect to
         all of the named servers.

>>INDEX<<copy
      COPY - copy a table definition
         Syntax: copy [table] <source table> to <destination table>;

         The copy command copies the table definition of <source table>,
         naming it <destination table>.  This allows the definition of a
         table to be copied without the tables records.  The insert command
         can be used to copy the desired records.

         Table <destination table> must not already exist, and will be
         created on the same server as <source table>.

           Example:
             copy table cust_list to new_tab;


>>INDEX<<create table
      CREATE TABLE - create a table at the data server.
        Syntax: create [table] <table_name> keys (key_field_list)
                       [allow delete] [allow keychange] [allow newfield]
                       buffer size <bytes> [minimum record <bytes>];

         <table_name> is the name of the table to be created.
         Following the required word 'keys' is the <key_field_list>, enclosed
         in parentheses.  <key_field_list> is the list of fields to use as
         the primary key for the table.  See the section 'REFERENCING FIELDS
         THROUGH QL' for an explanation of accepted field naming conventions.
         The key_field names in the list may be followed by a key segment
         modifier with may be one of:
             ASC or ascending;   (the default)
             DESC or descending;
             SERIAL or Generated.  Generated keys may have only one field
               in the list and that field must have datatype FT_INT.

         The two optional "allow" parameters set table permissions.  If
         'allow delete' is specified, deletes will be allowed on records in
         the table.  If 'allow keychange' is specified, updates that change
         the values of fields within the key will be allowed.
         If 'allow newfield' is specified, updates that add a field to a
         record will be allowed.

         The 'buffer size' parameter is required, and specifies the number of
         bytes for RT to allocate for reading and writing the table records.
         The buffer size must be large enough to hold the largest record in
         the table.  Refer to the section on 'cbs - Calculate Buffer Size for
         cdserver table context' for information on determining the proper
         size.

         The optional 'minimum record' parameter specifies the minimum space
         to allocate for a record in this table.  This is for performance
         tuning on tables whose records are frequently deleted or updated to
         increase the record length by more than 12.5% The minimum record
         size must be less than or equal to the buffer size.

           Examples:
             create phone_list keys (common:last_name common:area_code
                    common:phone_number) allow delete allow keychange
                    buffer size 120;
             create table cars keys (common:license)
                    buffer size 100;
             create table boats keys (common:license)
                    buffer size 300;

>>INDEX<<create index
      CREATE INDEX - create an additional index on a table.
         Syntax: create [unique|distinct] index <index_name> on <table_name>
                 (<key_field_list>) [allow keychange];

         This command creates a new index on the named table.  This index is
         in addition to any existing indexes.  If unique or distinct is
         specified, you will not be allow to create the index unless all
         existing records have unique keys under this new index.

         <index_name> is the name to use for later reference of the index.
         Currently, the index name cannot be longer than 8 characters.

         <table_name> is the name of the table that the new index is to be
         associated with.

         <key_field_list> is the list of fields that compose the key.  Each
         field ID in the list may be followed by an optional segment modifier
         which must be one of:
             asc or ascending;
             desc or descending;
             sparse.
         If the modifier is 'sparse', no index record will exist in the index
         btree for base records with the corresponding field missing or of
         zero length.  Single character FT_ASCII fields are best for these
         fields, though any data type will work.

         The "allow" parameter sets index permissions.  If 'allow keychange'
         is specified, updates that change the values of fields within this
         key will be allowed.

         Alternate indexes may be used in select statements using the 'sort
         by' or 'order by' options.  Alternate indexes may be removed from
         tables using the 'drop index' command.  Having more than one index
         on a table may have an adverse affect on performance, so they should
         be used wisely.
             Examples:
               create unique index phone on customer (common:phone_no)
                      allow keychange;
               create index model on car (common:car_model);

>>INDEX<<declare
      DECLARE - declare a cursor on a table.
         Syntax: declare <cursor_name> [cursor for <select statement>];

         Cursors are used for record at a time processing.  A cursor can be
         thought of as a pointer to a record within a set of records.  The
         set of records is determined by the select statement.

         <cursor_name> is the name to be used for future references to the
         cursor.  If the optional statement is not included, the cursor will
         be associated with all of the records in the table 'journal'.  If
         the optional statement is included, the cursor will be associated
         with the records that satisfy the select statement.

         The cursor is opened as part of the 'declare' operation.

         <select statement> is basically the same as the 'select' command,
         with the exception that cursors do not support the count option. See
         the 'select' command for <select statement> syntax and explanations.

         Examples:
                 declare jnl_cursor;
                 declare local_calls cursor for select from phone_list
                         where common:area_code == 509;

>>INDEX<<delete
      DELETE - delete records from a table.
         Syntax: delete [<count>| all] [from <table_name>]
                         [where <criteria> | where current of <cursor_name>];

         The first optional parameter determines the number of records to
         delete.  If the optional count is not entered, all of the records
         that fit the 'where <criteria>' are deleted.  Using 'all' has the
         same effect as not entering a count.  If <n> is used, up to <n>
         records that fit the 'where <criteria>' will be deleted.  When
         specifying a count, be aware that order is important.  The default
         order is 'ascending', meaning that records will be deleted starting
         with the record with the lowest key.  If 'descending' is specified
         in the <criteria> then the records will be deleted starting with the
         record with the highest key.

         If the optional <table_name> is not given, the journal table is used
         by default.  Generally, the journal table is created without delete
         permissions.  ql will report an error if you attempt to delete
         records from a table without the appropriate permissions.

         If the optional 'where <criteria>' is used, the records used for
         delete are restricted to those records that match <criteria>.  If
         'where <criteria>' is not entered, all records in the table are
         selected.  <criteria> is defined in the section titled PRETTY
         QUICK LANGUAGE, with the exception of how fields may be specified.
         See the section 'REFERENCING FIELDS THROUGH QL' for an explanation
         on accepted field naming conventions.

         The current record within a cursor can be deleted using the 'where'
         syntax: 'where current of <cursor_name>'.  The current record of the
         cursor must be held with lock.  (See the fetch command).  Only the
         current record of the cursor is deleted, the <count> option is
         ignored.  After completion, the cursor will no longer have a current
         record, a 'fetch first' or 'fetch last' can be used to establish a
         current record.

         Examples:
                 delete from phone_list where common:last_name == "Smith";
                 delete 1 from cars where common:make == "Ford";
                 delete from cars where current of edsels;

>>INDEX<<disconnect
      DISCONNECT - disconnect from a server.
         Syntax:  disconnect from <server_name>
                         disconnect using <table_name>

         If the server_name is used, ql will attempt to disconnect from the
         server of that name for your given project and revision.

         If the table_name is used, ql will attempt to get a list of server
         names for that table by selecting all of the common:Cds_server_name
         fields from the table records.  Ql will then attempt to disconnect
         to all of the named servers.

         If the command completes successfully, you will no longer have
         access to the server(s) that were disconnected.

>>INDEX<<display
      DISPLAY - display list of tables or indexes
         Syntax:  
           display tables [<service_name_suffix>] [into|onto pager|<file>];
           display indexes [on <table_name>] [into|onto pager|<file>];

         "display tables" shows the number of tables and the current size of
          the recovery log file, and for each table: the table name, 
          record count, byte count and average record size, in terms of space 
          used.  The byte count does not include space occupied by deleted
          records.

         "display indexes" shows the table name, index name, field ID -
          application name and field name, and segment modifier for each
          index.

>>INDEX<<drop table
      DROP TABLE - delete a cdserver table.
         Syntax: drop [table] <table_name>;

         <table_name> is the name of the cdserver table to drop.  If the
         table does not exist, ql will report an error.  At completion of the
         command, the table and all of its contents will be gone.

         Examples:
                 drop table phone_list;
                 drop cars;

>>INDEX<<drop index
      DROP INDEX - delete an index from a table.
         Syntax: drop index <index_name> from <table_name>;

         <index_name> is the name of the index to drop from the the table
         <table_name>.  After the command is completed, the index will no
         longer exist for the table.  This command is not allowed if the
         index is currently in use by some context.  You are not allowed to
         drop the primary index from a table.

         Examples:
                 drop index callcode from phone_list;
                 drop index model from cars;


>>INDEX<<edit
      EDIT - edit a history command.
         Syntax: edit [n] [run];

         This command allows you to edit a history command, and optionally
         run the command on completion of the edit.  If the command number is
         not specified, the last command entered will be edited.  If the
         keyword run is given, the edited command will be executed on return
         from editing.  The edited command is always placed in the history
         list as the last command.  The edit command is not saved in the
         history list.

         Editing is done using one of the system's text editors.  The default
         editor is determined by checking the environmental variable
         'EDITOR'.  If this variable is not set, the editor defaults to
         'edit'.  The editor setting can be changed within ql by using the
         'set editor' command.

         Example:
                 edit; edits the last command
                 edit run; edits the last command and runs it
                 edit 6; edits command number 6

>>INDEX<<exit
      EXIT - exit ql.
         Syntax: exit;

         This command terminates ql.  It is identical to quit and q.

         Example:         exit;

>>INDEX<<fetch
      FETCH - set the cursor to a record.
         Syntax: fetch [<orientation>] [from] <cursor_name> [with lock];

         <orientation> can be one of: first, last, next, or prior, or it can
         be a record count and skip count.  If record count is used, up to
         record_count records will be returned.  A positive record_count will
         search forward, and a negative count will search backward.  If the
         record_count is followed by a skip_count, then skip_count records
         will be skipped before starting to return qualified record. If no
         orientation is specified, the orientation defaults to 'next'.

         <cursor_name> is the name of a valid cursor (declared and not yet
         closed).  If the record can be found, the cursor is positioned to
         the record and the record is displayed.

         If the optional 'with lock' is specified, the new record will be
         locked for update.  The update and delete commands can then effect
         the record.

         Examples:
                 fetch jnl_cursor;
                 fetch 10 from list;
                 fetch -5 3 from list;
                 fetch last from local_calls with lock;
                 fetch prior from local_calls;

>>INDEX<<h
      H - synonym for the history command.
         Syntax: h;

>>INDEX<<help
      HELP - display help for the requested function.
         Syntax: help [<function name>];

         The help function expects the file '\moa\lib\qlhelp' to exist
         and be a valid ql help file.  The ql help file is simply an ascii
         file with help index markers inserted into the text.  A help index
         marker starts in the absolute first column of a line, and consists
         of: >>INDEX<< followed by the text to use as the index.

         When help is requested for the first time, ql opens the help file and
         collects the names of all of the indexes.  When help is requested for
         one of the indexed strings, ql will display the text from the help
         file, starting at the index marker location, up to the next index
         marker.

         There are two settings for ql help.  The first is the help file
         name.  The default is '\moa\lib\qlhelp'.  The other setting is
         for the help pager.  The pager defaults to 'more'.

         Examples:
                 help create table;
                 help ql;

>>INDEX<<history
      HISTORY - display the history list.
         Syntax: history;

         Displays the history list.  This list includes the history command
         numbers to be used in the edit and run commands.  This command is
         not added to the history list.

         Example:
               history;

>>INDEX<<insert
      INSERT - inserts a record into a table.
        Syntax:
             insert [into] <table_name>]] (<field list>) values (<value list>);
             insert [into] <table_name>]] (<field list>) values
                    (<value list for record 1>)
                    (<value list for record 2>)
                    (<value list for record n>);
             insert [into <table_name>] from <file_name>;
             insert [into <table_name>] <select statement>;

         If <table_name> is not specified, 'journal' is used as the default.

         If the 'from' option is used, the records are inserted from a file.
         The file should contain records in a cds 'dump' format.  The file
         can be created by setting the target_db to cds (see SET), and then
         selecting from a table, dumping the output to a file.

         <field list> is the list of fields to be inserted.  See the section
          'REFERENCING FIELDS THROUGH QL' for an explanation on accepted
         field naming conventions.

         After the word 'values' is <value list>.  These are the values to be
         assigned to the fields in <field list>.  There must be a one-to-one
         correspondence between the fields and the values.  All key fields
         must be assigned values.

         The variation of insert that supports the select statement allows
         records from one table to be inserted into another table.  The
         <select statement> is a ql select statement.

         Examples:
           insert into phone_list (common:last_name, common:area_code
                   common:phone_number, common:address, common:contact_date)
                   values  ("Jones" 208 8675309 "N. 101 Sutter, Townsport"
                   19890820);
           insert into cars (common:license common:make)
                   values ("DOL 454", "Chevrolet")
                          ("COL 777", "Ford")
                          ("CAL 111", "Avanti");
           insert into new_tab from backup;
           insert into just_5 select 5 from list_tab;
           insert into big_new select na:cust_id na:cust_name from new_cust
                   where na:amount > 10000;


>>INDEX<<lock
      LOCK - issue a table level lock.
         Syntax: lock <table_list> [exclusive|update];

         <table_list> is the list of tables to lock.  All tables must be on
         the same server.

         If cds is unable to lock any of the tables, none of the tables are
         locked, and a message reports why the operation failed.  Update
         locking is the default, and allows other users to read records from
         the table, but does not allow other users to lock the records.
         Exclusive locking restricts all other users from accessing (reading,
         updating) the table.

         Examples:
             lock accounts;
             lock income expense update;
             lock payroll exclusive;

>>INDEX<<rename
      RENAME - rename a table.
         Syntax: rename <table_name> to <new_name>;

         <table_name> must be the name of a valid cdserver table.
         <new_name> must not already exist.  At completion of the command,
         the table <table_name> will be named <new_name>.

         Examples:
                 rename cars to autos;
                 rename current to old;

>>INDEX<<rollback
      ROLLBACK - rollback the current logical unit of work.
         Syntax: rollback | cancel [work | transaction]

         This command cancels the current logical unit of work (LUW), rolling
         back all changes made since the LUW was started.

>>INDEX<<run
      RUN - execute ql commands from a file.
         Syntax: run {[n]|[from] <file_name>};

         If a number is entered, this command will run a command from
         history.  The number is the number of the history command.  If the
         [from] filename syntax is used, ql executes commands from the file.
         <file_name> is the name of a file that contains valid ql commands.
         ql will execute commands from the file until the end of the file is
         reached or a 'quit' command is executed.  The 'quit' command will
         exit ql.

         Examples:
                 run from phone_list_update;
                 run from \moaproj\my\updates;
                 run 12;

>>INDEX<<select
      SELECT - get records from a table.
         Syntax: select [<count>| all] [[unique | semidistinct]<field list>]
                     [from <table_name>| <join_list>]
                     [where <criteria>]
                     [order | sort [[by <index_name>] ascending | descending]]
                                   | by <order field list>]   
                     [dump] {[pager]|[into | onto <file_name>]};

         The first optional parameter indicates the number of records to
         select.  If the parameter is not entered or 'all' is entered, all
         records that match <criteria> are returned.

         If a projection <field list> is specified, it indicates that only the
         named fields are to be displayed (this is referred to as a projection).
         Projections are displayed in a columnar format.  If the "unique"
         option is given in front of the projection field list then only
         unique records will be returned from the server.  If "semidistinct"
         option is used, adjacent duplicates will be removed from the result,
         but non-adjacent duplicates are allowed.

         If a projection <field list> is not given, all of the fields from each
         record are displayed, one line per field.  Using the basic field list
         will cause ql to use the field name as the column title.  Titles and
         column widths can be set using modifiers.  Each field definition
         supports the modifiers 'as <title>' and 'width <size>'.  Literals
         may be included in the <field list> by enclosing them in quotes. The
         literal will appear in the title and in its column for each record
         selected.  Aggregates may also be used in the field list. The
         supported aggregates are: min(<field>), max(<field>),
         count(<field>), sum(<field>), and avg(<field>).

         Aggregates act on all of the qualified records of the context, and
         return a single result.  Therefore, any selection using an aggregate
         will return a single record as the response.

         count returns the number of records in the context.  The field name
         that is enclosed in parenthesis is the field to return the count
         value in.

         max and min return the maximum and minimum values for the named
         field.  These functions are valid on fields with data types of
         ASCII, NUMERIC, DATE, TIME, INT, and FIXED.

         sum and avg return the sum and average values for the named field.
         The average is computed by dividing the sum for the field by the
         record count.  These functions are valid on fields of type NUMERIC,
         INT, and FIXED.

         If the optional <table_name> is not specified, it defaults to
         'journal'.

         A <join_list> is used to request a 'join' of the data from multiple
         tables.  The <join_list> has the format:
          {<table_name>[preserve] [as <as_name> [sort|order by <index_name>]]}
         The table_name is the name of the cds table.  The optional key word
         "preserve" indicates preservation of unmatched records in an outer
         join.  An optional 'as' name can be specified.  This name can be used
         as a short-hand in the <criteria>.  It is also used as context name 
         at the server, replacing any existing context of the same name.  If
         an 'as' name is specified, then a sort or order statement is allowed.
         The ordering of the data for the table is determined by the
         index_name specified, with the primary index being the default.

         If the optional 'where <criteria>' is not specified, the select will
         match all records within the table.  <criteria> is defined in the
         section titled PRETTY QUICK LANGUAGE, with the exception of how
         fields may be specified.  See the section 'REFERENCING FIELDS
         THROUGH QL' for an explanation of accepted field naming conventions.

         The order that the records will be returned is controlled by the
         optional 'order' clause.  Records can be ordered in either
         ascending or descending sequence on an indexed key.  The default is
         ascending order.  If the 'by <index_name>' option is used, the named 
         index will be used for record retrieval.  If you use the "order by"
         clause and don't name an index, the primary index will be used.
         If you provide an 'order by' field list, the server will either find
         an existing index that matches your request, or return an error.

         If the 'dump' option is specified, the output will be in a format
         that can be loaded into a database.  Because CDS allows variable format
         records, the dump option requires a projection list for dumping in
         database formats.  Dumping in cds format does not require a projection.
         The dump format is determined by the target_db setting.
         See SET for how to change the target_db setting.

         The output of the select can be redirected using the 'into' or
         'onto' options.  When a file name is specified, 'into' will over-
         write <file_name> if it already existed.  'onto' will append to
         <file_name> if it already existed.  <file_name> is the file to send
         the output to.  If the keyword 'pager' is used, the output will be
         redirected to the pager as defined by the setting 'pager'.  The
         default pager is 'more'.

          Examples:
               select 4 from phone_list where common:area_code == 509 &&
                     (common:last_name == "Smith" ||
                      common:last_name == "Jones")
                     order descending into /tmp/tocall;
               select from autos;
               select common:last_name common:phone_number from phone_list
                     where common:last_name > c && common:last_name < n
                     dump into callc-m;
               select from phone_list order by callcode descending;
                  ; requires an index named 'callcode' to exist on phone_list
               select common:amount as owed width 6 from debit;
               select avg(common:amount) sum(common:amount)
                      max(common:amount) "LATE" from debit where
                      common:due_date < 19900606;
               select common:amount "LATE" from debit
                      where common:due_date < 19900606;
               select count(common:int_field) sum(common:int_field)
                      min(common:int_field) max(common:int_field)
                      avg(common:int_field) from vol_tbl;
               select unique common:Cds_table_name, :Cds_index_name
                      from tables as t, indexes as idx
                      where t.:Cds_table_no == idx.:Cds_table_no;

>>INDEX<<set
      SET - set ql variables.
         Syntax: set [<option> <new_setting>];

         This command sets internal ql variables.  If the optional parameter
         is not entered, set returns the current settings.

         The following may be set through the set command:

         ttttaaaabbbblllleeee - 'set table <table name>;' sets the default table to the
          named table.  Most of the ql commands will use the default table
          name if a table name is not given.

         aaaapppppppplllliiiiccccaaaattttiiiioooonnnn - 'set application <application>;' sets the default
          application to the named application.  The default application can
          be used when referencing fields simply by not using the application
          name or number.  Note that within a single command, the default
          application starts as the application defined in the set variable,
          but when an application is specified in a field reference, that
          application becomes the default until either a new application name
          is specified in the command or the command terminates.  When the
          command terminates, the default is reset to the application defined
          in the set variable.

         ttttaaaarrrrggggeeeetttt____ddddbbbb - 'set target_db <db name>;' set the target database for
          the dump option of the select statement.  Cds will dump the data in
          a format readable by the target database.  See the section on
          MOVING CDS DATA TO/FROM A DATABASE.

         history eeeeddddiiiittttoooorrrr - 'set editor <editor name>;' sets the name of the
          editor to be used for history command editing.  The default is the
          editor defined in the environmental variable EDITOR.  If this
          variable is not set, the default is 'edit'.

         ppppaaaaggggeeeerrrr - 'set pager <pager>;' sets the name of the program to use
          when the 'into pager' option is used in the select command.
          Defaults to 'more'.

         hhhheeeellllpppp ffffiiiilllleeee - 'set help file <file name>;' sets the help file to the
          file specified.  Default is '\moa\lib\qlhelp'.

         hhhheeeellllpppp ppppaaaaggggeeeerrrr - 'set help pager <pager>;' sets the pager to be used
          with ql help.  Defaults is 'more';

         ffffiiiieeeelllldddd____sssseeeepppp - 'set field_sep <separator>;' sets the character that
          will be used as the field separator character for dump and
           'insert from' operations.  The setting must be a single printable
          character.  Default is '|'.

         name_sep 	 'set name_sep <separator>;' sets the character that
            will be used as the field_name separator character for fixed format
            projection lists in dump and 'insert from' operations.  
            The setting must be a single printable character.  This is 
            initialized from environment variable, QL_NAME_SEP, or defaults to
            ':' if QL_NAME_SEP is not defined. Don't try to use this for 
            anything besides dump and insert operations.  It doesn't work in 
            'where' clauses.
 
        ppppaaaaggggeeee lllleeeennnnggggtttthhhh - 'set page length <length>;' sets the length of a
          report page.  This length is in effect for all data displayed by
          the select and fetch operations.

         ((((ddddiiiissssppppllllaaaayyyy)))) eeeeddddiiiitttt - 'set edit {on|off};' If edit is set to on, field
          values will be displayed using the edit patterns defined in the data
          dictionary field defintions  (where applicable).  If edit is
          set to off, the field values will be displayed without using edit
          patterns.

         ddddeeeebbbbuuuugggg - Used for ql debugging.

         Examples:
               set field_sep @;
               set target_db cds;
               set;
               set pager more;
               set editor vi;
               set application auto_loans;

>>INDEX<<start
      START - start a logical unit of work.
         Syntax: begin|start [work|transaction]

         This command starts a logical unit of work, that stays in affect
         until it is committed (COMMIT) or rolled back (ROLLBACK).


>>INDEX<<startcapture
      STARTCAPTURE - begin or resume logging all server messages at server   

        Syntax: startcapture;
   
        This command tells the server to start recording all messages to and
        from every client, for debugging and for guiding optimization efforts.
        The messages are recorded in a binary file, named capture, that may be
        printed with the prcaptur utility program.
 
      STOPCAPTURE - stop logging all server messages at server   


>>INDEX<<stopcapture
      STOPCAPTURE - stop logging all server messages at server   

        Syntax: startcapture;

   	This command tells the server to stop recording client messages. 
        See startcapture.


>>INDEX<<system
      SYSTEM - execute a shell command.
         Syntax: system <shell command>

         This command causes the execution of the shell
         (or command interpreter) command.  A new command interpreter
         is spawned to execute the command.
         At completion of the command, control is returned to ql.
         The command must be contained on a single ql command line.  Also,
         the semi-colon is not the ql command terminator, any semi-colons in
         <shell command> are passed to the shell as part of the command.
         This command is a synonym for the !  command.
           Examples:
               system dir
               system vi unload

>>INDEX<<unlock
      UNLOCK - release table locks.
         Syntax: unlock [<table_list>];

         <table_list> is the list of tables to unlock.  If no list is given,
         all table locks held by the user will be released.

         Examples:
             unlock;
             unlock income expense;

>>INDEX<<update
      UPDATE - update records in a table.
         Syntax: update [<count>|all] [<table_name>] set
                          <field_assign>[{, <field_assign>}]
                          [where <criteria>| current of <cursor_name>];

         The first optional parameter is the count for the number of records
         to update.  If the parameter is not entered, or 'all' is entered,
         all of the records that match <criteria> will be updated.  If
         <count> is given, then up to <count> records will be updated.

         <table_name> is the name of the table to update.  The default name
         is 'journal'.

         <field_assign> is a field assignment of the form: <field> = <value>.
         There must be at least one <field_assign>.  Only fields that already
         exist in the record may be updated.  To add a new field to the
         record using ql, try "help advanced examples;".

         If the optional 'where <criteria>' is used, the records used for
         update are restricted to those records that match <criteria>.  If
         'where <criteria>' is not entered, all records in the table will be
         updated (in the absence of locks).
         <criteria> is defined in the section titled PRETTY QUICK
         LANGUAGE, with the exception of how fields may be specified.
         See the section 'REFERENCING FIELDS THROUGH QL' for an explanation
         on accepted field naming conventions.  Fields that are part of the
         key for the table can only be updated if the table was created with
         the 'allow keychange' option and the "where current of <cursor>"
         option is used.

         The update operation can be applied against the current record in a
         cursor using the 'where current of <cursor_name>' syntax.  The
         cursor must have a current record, and that record must be locked by
         the cursor.  (See the fetch command).

          Examples:
               update phone_list set common:zip_code = 663324444
                     where common:zip_code == 66332;
               update autos set common:owner = "Larson"
                     common:address = "E. 12 Trent, Mowtown"
                     where common:license == "AX1 222";
               update autos set common:owner = "Spaldings"
                     where current of wrecked;

>>INDEX<<q
      Q - exit ql.
         Syntax: q

         This command terminates ql.  It is a synonym for quit and exit.

>>INDEX<<quit
      QUIT - exit ql.
         Syntax: quit;

         This command terminates ql.  It is identical to exit.

         Example:
               quit;

>>INDEX<<!
      ! - execute a shell command.
         Syntax: ! <shell command>

         This command causes the execution of the shell
         (or command interpreter) command.  A new command interpreter
         is spawned to execute the command.
         At completion of the command, control is returned to ql.
         The command must be contained on a single ql command line.  Also,
         the semi-colon is not the ql command terminator, any semi-colons in
         <shell command> are passed to the shell as part of the command.
         A space is required between the !  and the shell command.
           Examples:

               ! dir
               ! edit unload
               ! dir; vi ...

>>INDEX<<referencing fields
    REFERENCING FIELDS THROUGH QL

       ql provides a number of ways to reference fields within records.  As
       the ql command examples show, you can reference the fields by name,
       listing the application name followed by a colon and the field name.
       You can also reference fields by number using the pql syntax of an 'f'
       followed by the application number, a colon, and the field number.  In
       ql, you can mix these methods, replacing names with numbers or numbers
       with names.

       The only case where a name cannot directly replace a number is when
       using the format: fn:nn.  In this format, you cannot replace the
       application number directly with application name, because the 'f'
       will be treated as part of the name.  The solution is to either drop
       the 'f' or follow the 'f' with the optional colon.

       Finally, ql supports a default application.  When ql is started, the
       default application is set to 'common'.  You can see the default by
       displaying the settings (using set).  At the start of each command,
       the default application is the one defined in the set variable. During
       the command, the default changes if an explicit application name is
       used.  At the end of the command, the default reverts back to the set
       variable.  To reference a field using the default application, simply
       omit the application name or number from the specification, leaving
       the colon and field name or number.

         Examples:
           (NOTE: default application starts as 'common')
           (Assume the following four field references are in one command)
           :ix_seqno - references this field in default application
           :23 - references field 23 in default application
           f4:ix_seqno - references ix_seqno in application 4.
                      The default application number is now 4.
           :23 - references field 23 in application 4
           (At the completion of the command, the default application
           reverts back to the application defined in the set variable.)

           (assume 'cust' is application 4, and 'amount' is field 10)

           f:4:10
           cust:10
           4:amount
           :10
           cust:amount
           :amount
                  - all of these reference field 10 of application 4.


>>INDEX<<moving data
    MOVING CDS DATA TO/FROM A DATABASE

       ql provides a way to move data to and from foreign data bases.  It
       involves the use of both ql and database 'dump' and 'load' facilities.
       The features are currently developmental, and will increase in
       functionality as requirements become clearer.

       Data can be dumped from ql in a format accepted by DBMS such as
       Empress and Informix, using the 'dump' option from the select
       statement.  Since data base systems have a fixed schema, always
       knowing the columns of a table and their order, ql will only allow you
       to dump projections into data base formats.  An example of setting up
       and dumping from ql into a format for an Empress table with the
       attributes first_name, last_name account_number and balance:
         set target_db empress;
         select ap:first_name, ap:last_name, ap:account, ap:bal from tab
                 where ap:bal > 10000 dump into savefile;

       The file savefile will contain a dump suitable for loading into
       Empress using the file option in the Empress insert command.

       Empress and Informix dump files basically consist of column data
       separated by 'separator characters', with each record terminated by a
       carriage return.  CDS allows you to set the value for the separator
       character, as part of the set command options.

       To dump data from a data base in a form that can be loaded by CDS, you
       must include the cds application and field name with the data. This
       can be done in Empress using a command like: select "ap:first_name",
       first_name, "ap:last_name", last_name from customer_table dump into
       dbdump;

       To load into CDS from the data base dump file, you must be certain
       that the field separator character is set to the character used in the
       data base dump.  The data can be loaded into CDS using the ql
       statement:
         insert into tab from dbdump;

       The future changes will include the ability to insert into CDS from
       a file with a projection specification, looking something like:
         insert ap:first_name, :last_name into tab from dbdump2;
       where the cds application name and field name would not be needed
       in the dump file.  This will simplify the data base select
       statements need to generate the dump file.


>>INDEX<<advanced examples
   ADVANCED EXAMPLES

       The basic command set for ql supports almost all of the data
       manipulation and data definition functions available from CDS. With
       some creative use of the full command set, additional ql functionality
       can be achieved.

       USING A FILE OF QL COMMANDS

       Often a user will wish to execute a set of commands a number of times,
       or the set may be complicated, and to avoid errors, the user will want
       to use an editor to enter the commands.  In such cases, the commands
       can be stored in a file for later execution.  To start ql and use a
       file for commands, use:

         ql -nproj < filename

       Within ql, a file of commands is run using:

         >run from filename;

       Scripts like mktelrtabs redirects into ql in the following manner:

         : "create tables for standard teller product"
         # 'adds only journal, totals, and profiles tables'

         USAGE="*** USAGE *** $0  [-nPROJ]"

         case $# in
          0)
            PROJECT="-n_xmp"
            ;;
          1)
            PROJECT=$1
            ;;
          *)
            echo "$USAGE"
            exit 1
            ;;
         esac

         ql $PROJECT <<'@'
         create table journal keys (common:ix_branch, :ix_operator_id,
           :ix_bus_date,  :ix_seqno);
         create table totals keys (common:ix_branch, :ix_operator_id)
            allow delete;
         create table profiles keys (common:ix_branch, :ix_operator_id)
            allow delete;
         quit;
         @

       The quit command as the final command is necessary to avoid having ql
       hang, waiting for more input.



       ADDING AND DELETING FIELDS FROM A TABLE

       CDS does not allow new fields to be added to an existing record when
       an update is performed.  OFB supports the CDS replace command, which
       does allow new fields to be added to, or existing fields to be omitted
       from the new record. Ql does not support the replace command.  There
       are ways to use ql to do many forms of table manipulation.  To add a
       new field to every record in a specific table, project every existing
       field in the table, and then list the new field(s) that are to be
       added. (The fields must be valid data dictionary fields.) Dump the
       projection into a file. This file can be used to insert the new
       records into CDS.  The new fields will have a null value.  At the same
       time, fields can be deleted from the existing records by projecting
       only those fields that are to be preserved.

       As an example, table PIC stores a customer name (name), account number
       (acct) and the customer's picture (pic).  It has been determined that
       the name field is not needed, since the reference is done by account
       number.  In addition, the date of the picture should be stored with
       the picture to determine how current the image is.  To remove the name
       field and add the picdate field through ql:

         select ap:acct ap:pic ap:picdate from pic dump into savefile;

       The file savefile will contain all of the records from the table, but
       each record will be missing the name field, and will include the
       picdate field (with a null value).

       To insert these new records back into the database, there are a number
       of options.  One of the safer approaches is to rename the current pic
       table, create a new pic table, and insert the new records into the new
       pic table.  Once satisfied with the new table, the original table can
       be dropped.

         rename pic to oldpic;
         ; create the new table for pic
         create table pic index (ap:acct) allow delete buffer size 16500;
         insert into pic from savefile;
         ; Once satisfied with the new pic
         drop oldpic;

       It is still necessary to update the new records to include the proper
       date for each picture.


       SIMULATING OFB COMMANDS

       It is important to remember that when using ql to test OFB logic, the
       cursor interface must be used.  The cursor in ql is synonymous with
       the OFB context.  Refer to the DECLARE, FETCH and CLOSE commands, as
       well as the cursor variations of the UPDATE and DELETE commands.

       To create a cursor, fetch a record, update the record, delete the
       record, and then close the cursor:

         declare tobig cursor for select from journal where ap:amount >
         9999;
         ; now have a cursor, similar to OFB context
         fetch first from tobig;
         fetch next from tobig with lock;
         ; lock was necessary for update
         update journal set ap:hoststat = "posted" where current of
         tobig;
         fetch last from tobig with lock;
         delete from journal where current of tobig;
         close tobig;
         ; close is the same as an end select in OFB

       Using the fetch command to test OFB find_n operations has proven
       useful in many instances.

       With the logical unit of work (LUW) support in ql, you can make
       changes, view the effect, and then roll back the changes:

         ; start a LUW
         begin work;
         ; change all records in totals table
         update totals set ap:balance = 0;
         select ap:bucket ap:balance from totals;
         ; all balance fields will be 0
         delete from totals where ap:bucket == 4;
         select ap:bucket ap:balance from totals;
         cancel work;
         ; totals table is back to original condition
         select ap:bucket ap:balance from totals;

